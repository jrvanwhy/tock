// Licensed under the Apache License, Version 2.0 or the MIT License.
// SPDX-License-Identifier: Apache-2.0 OR MIT
// Copyright Tock Contributors 2024.
// Copyright Google LLC 2024.

//! Generates the accessor trait for a peripheral module.

// A note on design: We provide default implementations for the trait methods.
// This allows unit tests to easily provide a fake that fakes a subset of the
// peripheral's registers. Providing default implementations has the risk that
// someone might accidentally forget to implement a method they intended to
// implement. However, the implementation that runs on hardware (via MMIO) is
// generated by this macro, and the other trait implementations will likely all
// be in tests, where an `unimplemented!()` panic will result in a test failure.
//
// Similarly, for the provided _unchecked implementations, we provide some error
// checking that is suitable for use in unit tests but unsuitable for embedded
// use. These implementation are overridden by the Mmio* implementation of
// Accessor.

use crate::{DataType, Input, Operation};
use proc_macro2::TokenStream;
use quote::quote;

mod array_read;
mod array_unsafe_read;
mod array_unsafe_write;
mod array_write;
mod scalars;

use array_read::array_read;
use array_unsafe_read::array_unsafe_read;
use array_unsafe_write::array_unsafe_write;
use array_write::array_write;
use scalars::scalar_method;

/// Generates the accessor trait definition.
pub fn accessor(input: &Input) -> TokenStream {
    use DataType::{Array, Scalar};
    use Operation::{Read, UnsafeRead, UnsafeWrite, Write};
    let visibility = &input.visibility;
    let name = &input.accessor;
    let generics = input
        .generics
        .iter()
        .map(|type_param| quote! { type #type_param; });
    let parts: Vec<_> = input
        .registers
        .iter()
        .flat_map(|register| {
            register
                .operations
                .iter()
                .map(|op| match (&register.data_type, op) {
                    (Array { value_type, len }, Read(_)) => {
                        array_read(&input.tock_registers, &register.name, value_type, len)
                    }
                    (Array { value_type, len }, Write(_)) => {
                        array_write(&input.tock_registers, &register.name, value_type, len)
                    }
                    (Array { value_type, len }, UnsafeRead(_)) => {
                        array_unsafe_read(&input.tock_registers, &register.name, value_type, len)
                    }
                    (Array { value_type, len }, UnsafeWrite(_)) => {
                        array_unsafe_write(&input.tock_registers, &register.name, value_type, len)
                    }
                    (Scalar { value_type }, _) => {
                        scalar_method(&input.tock_registers, &register.name, op, value_type)
                    }
                })
        })
        .collect();
    let definitions = parts.iter().map(|p| &p.definition);
    let deref_impls = parts.iter().map(|p| &p.deref_impl);
    let mmio_impls = parts.iter().map(|p| &p.mmio_impl);
    quote! {
        #visibility trait #name: Clone {
            #![allow(unused_variables)]
            #(#generics)*
            #(#definitions)*
        }

        // TODO: Deref and Mmio impls.
    }
}

struct Parts {
    definition: TokenStream, // Method declaration in the trait definition
    deref_impl: TokenStream, // Method implementation on the blanket impl
    mmio_impl: TokenStream,  // Method implementation on the Mmio* struct
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::test_util::assert_tokens_eq;
    use syn::parse_quote;

    #[test]
    // Note: If this test is failing, make sure the other tests in this module are
    // passing before debugging it! This exists to make sure that accessor_impl
    // is calling the correct methods for each register + operation and that it
    // is passing them the correct arguments.
    fn complex() {
        let expected = quote! {
            pub (super) trait Foo : Clone {
                #![allow(unused_variables)]

                type A: BusSize;
                type B: LiteXRegisters + BarConfig;

                #[doc = "Read the b register."]
                #[doc = "Returns `None` if `index` is >= 2."]
                fn b_read(&self, index: usize) -> tock_registers::reexport::Option<u16> {
                    tock_registers::reexport::unimplemented!()
                }
                #[doc = "Read the b register without bounds checking."]
                #[doc =
                    "Most users of tock-registers should not need to call or implement this function."]
                #[doc = "# Safety"]
                #[doc = "`index` must be less than 2."]
                #[doc(hidden)]
                unsafe fn b_read_unchecked(&self, index: usize) -> u16 {
                    tock_registers::reexport::assert!(index < 2,
                        "index out of bounds while reading b: the len is 2 but the index is {}", index);
                    self.b_read(index)
                        .expect("b_read called with in-bounds index but returned None")
                }

                #[doc = "Read the c register."]
                #[doc = "Returns `None` if `index` is >= 4."]
                #[doc = "# Safety"]
                #[doc = "Reading c has hardware-specific safety requirements."]
                unsafe fn c_read(&self, index: usize) -> tock_registers::reexport::Option<u32> {
                    tock_registers::reexport::unimplemented!()
                }
                #[doc = "Read the c register without bounds checking."]
                #[doc =
                    "Most users of tock-registers should not need to call or implement this function."]
                #[doc = "# Safety"]
                #[doc = "`index` must be less than 4."]
                #[doc = "Reading c has hardware-specific safety requirements."]
                #[doc(hidden)]
                unsafe fn c_read_unchecked(&self, index: usize) -> u32 {
                    tock_registers::reexport::assert!(index < 4,
                        "index out of bounds while reading c: the len is 4 but the index is {}",
                        index);
                    self.c_read(index)
                        .expect("c_read called with in-bounds index but returned None")
                }

                #[doc = "Write the c register."]
                #[doc = "Returns `Err` if `index` is >= 4."]
                #[doc = "# Safety"]
                #[doc = "Writing c has hardware-specific safety requirements."]
                unsafe fn c_write(&self, index: usize, value: u32) ->
                    tock_registers::reexport::Result<(), tock_registers::OutOfBounds>
                {
                    tock_registers::reexport::unimplemented! ()
                }
                #[doc = "Write the c register without bounds checking."]
                #[doc =
                    "Most users of tock-registers should not need to call or implement this function."]
                #[doc = "# Safety"]
                #[doc = "`index` must be less than 4."]
                #[doc = "Writing c has hardware-specific safety requirements."]
                #[doc(hidden)]
                unsafe fn c_write_unchecked(&self, index: usize, value: u32) {
                    tock_registers::reexport::assert!(index < 4,
                        "index out of bounds while writing c: the len is 4 but the index is {}",
                        index);
                    self.c_write(index, value)
                        .expect("c_write called with in-bounds index but returned None");
                }

                #[doc = "Write the d register."]
                #[doc = "Returns `Err` if `index` is >= 2."]
                fn d_write(&self, index: usize, value: u64) ->
                    tock_registers::reexport::Result<(), tock_registers::OutOfBounds>
                {
                    tock_registers::reexport::unimplemented!()
                }
                #[doc = "Write the d register without bounds checking."]
                #[doc =
                    "Most users of tock-registers should not need to call or implement this function."]
                #[doc = "# Safety"]
                #[doc = "`index` must be less than 2."]
                #[doc(hidden)]
                unsafe fn d_write_unchecked(&self, index: usize, value: u64) {
                    tock_registers::reexport::assert!(index < 2,
                        "index out of bounds while writing d: the len is 2 but the index is {}",
                        index);
                    self.d_write(index, value)
                        .expect("d_write called with in-bounds index but returned None");
                }

                #[doc = "Read the e register."]
                fn e_read(&self) -> u128 {
                    tock_registers::reexport::unimplemented!()
                }

                #[doc = "Write the e register."]
                #[doc = "# Safety"]
                #[doc = "Writing the e register has hardware-specific safety requirements."]
                unsafe fn e_write(&self, value: u128) {
                    tock_registers::reexport::unimplemented!();
                }
            }
        };
        assert_tokens_eq(
            accessor(&parse_quote! {tock_registers;
                pub(super) Foo<A: BusSize, B: LiteXRegisters + BarConfig> {
                     0 => a: u8[3] {},
                     3 => b: u16[2] { Read },
                     7 => c: u32[4] { UnsafeRead, UnsafeWrite },
                    23 => d: u64[2] { Write },
                    39 => e: u128 { Read, UnsafeWrite },
            }}),
            expected,
        );
    }
}
